# -*- coding: utf-8 -*-
"""Untitled0.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1sVdbF-b0E1t9uZ1u7wkhHsRBaaIvocYi
"""

# -----------------------------------------------------------------------------
# 1. SETUP: INSTALL LIBRARIES AND IMPORT NECESSARY MODULES
# -----------------------------------------------------------------------------
print("Starting setup and installation...")

# Install necessary libraries (Use this in the first Colab cell)
!pip install pandas numpy matplotlib tensorflow yfinance scikit-learn

# Import libraries
import numpy as np
import pandas as pd
import yfinance as yf
import matplotlib.pyplot as plt
from sklearn.preprocessing import MinMaxScaler
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import LSTM, Dense, Dropout

# Set display options for better output visualization
pd.set_option('display.max_rows', 5)
pd.set_option('display.max_columns', None)

print("Setup complete. Libraries imported.")

# -----------------------------------------------------------------------------
# 2. DATA ACQUISITION AND INITIAL PREPARATION
# -----------------------------------------------------------------------------
TICKER = 'AAPL' # Apple Inc. - widely available data
START_DATE = '2015-01-01'
END_DATE = '2025-10-01'
TIME_STEP = 60 # Look back window (60 days)
TRAINING_RATIO = 0.8 # 80% for training

print(f"\nFetching data for {TICKER} from {START_DATE} to {END_DATE}...")

try:
    data = yf.download(TICKER, start=START_DATE, end=END_DATE)
    if data.empty:
        raise ValueError("Data frame is empty. Check ticker or date range.")
    print(f"Successfully fetched {len(data)} rows of data.")
except Exception as e:
    print(f"Error fetching data: {e}. Check yfinance connection or ticker symbol.")
    exit()

# Use the 'Close' price for prediction and reshape for scaling
close_prices = data['Close'].values.reshape(-1, 1)

# -----------------------------------------------------------------------------
# 3. DATA NORMALIZATION AND SEQUENCE CREATION
# -----------------------------------------------------------------------------

# Normalize the data
scaler = MinMaxScaler(feature_range=(0, 1))
scaled_data = scaler.fit_transform(close_prices)

# Define training and testing sets
training_data_len = int(len(scaled_data) * TRAINING_RATIO)
train_data = scaled_data[0:training_data_len, :]
# Include TIME_STEP days overlap for the test set to create initial sequences
test_data = scaled_data[training_data_len - TIME_STEP:, :]


# Function to create the LSTM dataset sequences
def create_dataset(data, time_step=TIME_STEP):
    X, y = [], []
    for i in range(time_step, len(data)):
        # X: 60 previous prices
        X.append(data[i - time_step:i, 0])
        # Y: the current price (the one to predict)
        y.append(data[i, 0])
    return np.array(X), np.array(y)

# Create datasets
X_train, y_train = create_dataset(train_data, TIME_STEP)
X_test, y_test = create_dataset(test_data, TIME_STEP)

# Reshape input to be (samples, timesteps, features) for LSTM
X_train = X_train.reshape(X_train.shape[0], X_train.shape[1], 1)
X_test = X_test.reshape(X_test.shape[0], X_test.shape[1], 1)

print(f"\nTraining set shape (Samples, Timesteps, Features): {X_train.shape}")


# -----------------------------------------------------------------------------
# 4. BUILD AND TRAIN THE LSTM MODEL
# -----------------------------------------------------------------------------

# Build the Sequential LSTM model
model = Sequential()
model.add(LSTM(units=50, return_sequences=True, input_shape=(X_train.shape[1], 1)))
model.add(Dropout(0.2))

model.add(LSTM(units=50, return_sequences=False))
model.add(Dropout(0.2))

model.add(Dense(units=25))
model.add(Dense(units=1))

# Compile the model
model.compile(optimizer='adam', loss='mean_squared_error')
print("\nModel Architecture:")
model.summary()

# Train the model
# NOTE: Increase epochs (e.g., to 50 or 100) for better accuracy, but longer runtime.
print("\nStarting model training...")
history = model.fit(X_train, y_train, batch_size=32, epochs=25)
print("Model training complete.")

# -----------------------------------------------------------------------------
# 5. PREDICTION AND INVERSE SCALING
# -----------------------------------------------------------------------------

# Make predictions on the test set
predictions = model.predict(X_test)

# Inverse transform the predictions to the original price scale
predictions = scaler.inverse_transform(predictions)
y_test_unscaled = scaler.inverse_transform(y_test.reshape(-1, 1))

# Calculate Root Mean Squared Error (RMSE) for evaluation
rmse = np.sqrt(np.mean(predictions - y_test_unscaled)**2)
print(f"\nRoot Mean Squared Error (RMSE): {rmse:.2f}")


# -----------------------------------------------------------------------------
# 6. PLOT PREDICTIONS VS ACTUAL PRICES
# -----------------------------------------------------------------------------

# Prepare the final dataframe for plotting
train = data[:training_data_len]
# Use .copy() to ensure the DataFrame is a separate object for assignment
valid = data[training_data_len:].copy()
valid['Predictions'] = predictions # Add the predictions to the validation set

plt.figure(figsize=(16, 8))
plt.title(f'{TICKER} Stock Price Prediction (LSTM)')
plt.xlabel('Date', fontsize=18)
plt.ylabel('Close Price (USD)', fontsize=18)

plt.plot(train['Close'], label='Training Data')
plt.plot(valid['Close'], label='Actual Price', color='blue')
plt.plot(valid['Predictions'], label='Predicted Price', color='red', linestyle='--')

plt.legend(loc='lower right', fontsize=15)
plt.grid(True)
plt.show()


# -----------------------------------------------------------------------------
# 7. INTEGRATE AND PLOT TECHNICAL INDICATORS (SMA & RSI)
# -----------------------------------------------------------------------------

# Function to compute Relative Strength Index (RSI)
def compute_rsi(data, window=14):
    delta = data['Close'].diff()
    gain = (delta.where(delta > 0, 0)).rolling(window=window).mean()
    loss = (-delta.where(delta < 0, 0)).rolling(window=window).mean()
    rs = gain / loss
    rsi = 100 - (100 / (1 + rs))
    return rsi

# Create a copy of the original data for indicators
indicator_data = data.copy()

# Add Simple Moving Averages (SMA)
indicator_data['SMA_50'] = indicator_data['Close'].rolling(window=50).mean()
indicator_data['SMA_200'] = indicator_data['Close'].rolling(window=200).mean()

# Add Relative Strength Index (RSI)
indicator_data['RSI'] = compute_rsi(indicator_data)

print("\nTechnical Indicator Data (Last 5 rows):")
print(indicator_data[['Close', 'SMA_50', 'SMA_200', 'RSI']].tail())

# Plotting Price vs Moving Averages
plt.figure(figsize=(16, 6))
plt.title(f'{TICKER} Price and Moving Averages')
plt.plot(indicator_data['Close'], label='Close Price')
plt.plot(indicator_data['SMA_50'], label='SMA 50')
plt.plot(indicator_data['SMA_200'], label='SMA 200')
plt.legend(loc='upper left')
plt.grid(True)
plt.show()


# Plotting RSI
plt.figure(figsize=(16, 4))
plt.title(f'{TICKER} Relative Strength Index (RSI)')
plt.plot(indicator_data['RSI'], label='RSI (14 days)', color='purple')
plt.axhline(70, linestyle='--', alpha=0.5, color='red', label='Overbought (70)')
plt.axhline(30, linestyle='--', alpha=0.5, color='green', label='Oversold (30)')
plt.legend()
plt.grid(True)
plt.show()